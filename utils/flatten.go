package utils

import (
	"reflect"
	"strings"
)

const FLATTENING_SEPARATOR = "."

func flattenStruct(i interface{}, parents []string) map[string]interface{} {
	val := reflect.ValueOf(i)
	typ := reflect.TypeOf(i)

	if val.Kind() == reflect.Ptr {
		val = val.Elem()
		typ = typ.Elem()
	}

	result := make(map[string]interface{})

	for i := 0; i < typ.NumField(); i++ {
		fieldType := typ.Field(i)
		tag := fieldType.Tag.Get("mapstructure")

		if tag == "" {
			continue
		}

		fieldValue := val.Field(i)
		if fieldValue.Kind() == reflect.Ptr {
			fieldValue = fieldValue.Elem()
		}

		if fieldValue.Kind() == reflect.Struct {
			nextParents := make([]string, len(parents)+1)
			var i int
			for i = 0; i < len(parents); i++ {
				nextParents[i] = parents[i]
			}
			nextParents[i] = tag

			for k, v := range flattenStruct(fieldValue.Interface(), nextParents) {
				result[k] = v
			}
		} else {
			keys := append(parents, tag)
			flatKey := strings.Join(keys, FLATTENING_SEPARATOR)
			result[flatKey] = fieldValue.Interface()
		}
	}

	return result
}

// FlattenStruct takes a nested struct, with inner structs and flatten all the
// nested attributes into a single-level map[string]inteface{}. The keys are
// the generated by the concatenation of tags `mapstructure` on each field
// separated by dot.
func FlattenStruct(i interface{}) map[string]interface{} {
	return flattenStruct(i, []string{})
}
